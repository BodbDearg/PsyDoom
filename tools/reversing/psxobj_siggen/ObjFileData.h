#pragma once

//------------------------------------------------------------------------------------------------------------------------------------------
// Data structures describing a parsed .OBJ file dump generated by 'DUMPOBJ.EXE'.
// Describe the contents of the OBJ file.
//------------------------------------------------------------------------------------------------------------------------------------------
#include <cstddef>
#include <cstdint>
#include <string>
#include <vector>

// Represents a section type in the OBJ file
enum class ObjSectionType : uint16_t {
    RDATA,      // Read only data
    TEXT,       // Code
    DATA,       // Writable data
    SDATA,      // Writable data addressable as an offset to '$gp'
    SBSS,       // Non explicitly initialized data, addressable as an offset to '$gp'
    BSS,        // Non explicitly initialized data
    CTORS,      // Module initialization functions
    DTORS       // Module tear down functions
};

// Represents a patch applied to a piece of code or data.
// Note: in order to keep things simple I don't bother parsing out all of the info involved in the patch because patch source
// expressions can be pretty complex in the textual OBJ dumps. All I need to know is WHAT is being patched, i.e the offset.
// This is enough to mark instructions as wildcards for function signature matching.
struct ObjPatch {
    uint32_t    type;
    uint32_t    targetOffset;

    inline ObjPatch() noexcept
        : type(UINT32_MAX)
        , targetOffset(UINT32_MAX)
    {
    }
};

// Represents a section of a particular type in the object file.
// The section can contain code or data and any number of patches applied at link time.
struct ObjSection {
    static constexpr uint16_t MAX_SECTION_NUMBER = 0xFFFEu;

    uint16_t                    number;
    ObjSectionType              type;
    uint16_t                    alignment;
    uint16_t                    group;
    std::vector<std::byte>      data;
    std::vector<ObjPatch>       patches;

    inline ObjSection() noexcept
        : number(UINT16_MAX)
        , type()
        , alignment(UINT16_MAX)
        , group(UINT16_MAX)
        , data()
        , patches()
    {
    }
};

// Represents a symbol defined in the object file.
// The symbol can be defined within a section in the object file, or externally defined.
struct ObjSymbol {
    static constexpr uint16_t EXTERNAL_SECTION = UINT16_MAX;
    static constexpr uint32_t EXTERNAL_OFFSET = UINT32_MAX;
    static constexpr uint32_t NO_SYMBOL_NUMBER = UINT32_MAX;
    static constexpr uint32_t UNDEFINED_SIZE = UINT32_MAX;

    uint32_t        number;         // 'NO_SYMBOL_NUMBER' if a symbol number is not assigned (true for local variables)
    uint16_t        defSection;     // 'EXTERNAL_SECTION' if externally defined
    bool            bIsLocal;       // True if it is private to the OBJ file
    uint32_t        defOffset;      // 'EXTERNAL_OFFSET' if externally defined
    uint32_t        defSize;        // Only used for BSS symbols
    std::string     name;

    inline ObjSymbol() noexcept
        : number(UINT32_MAX)
        , defSection(UINT16_MAX)
        , bIsLocal(false)
        , defOffset(UINT32_MAX)
        , defSize(UNDEFINED_SIZE)
        , name()
    {
    }

    inline bool isExternal() const noexcept {
        return (defOffset == EXTERNAL_OFFSET || defSection == EXTERNAL_SECTION);
    }
};

// Container for the entire object file.
// Contains all of the sections and symbols defined in the object file.
struct ObjFile {
    std::vector<ObjSection> sections;
    std::vector<ObjSymbol>  symbols;
    uint32_t                curSectionNumber;       // Parser state
    uint32_t                curPatchBaseOffset;     // This should be added to whatever offset is specified in a patch directive
    uint16_t                lnkVersion;             // Should be '2'
    uint16_t                processorType;          // Should be '7' for MIPS

    inline ObjFile() noexcept
        : sections()
        , symbols()
        , curSectionNumber(UINT16_MAX)
        , curPatchBaseOffset(0)
        , lnkVersion(UINT16_MAX)
        , processorType(UINT16_MAX)
    {
    }

    inline ObjSection* getSectionWithNum(const uint32_t sectionNum) noexcept {
        for (ObjSection& section : sections) {
            if (section.number == sectionNum) {
                return &section;
            }
        }

        return nullptr;
    }

    inline const ObjSection* getSectionWithNum(const uint32_t sectionNum) const noexcept {
        for (const ObjSection& section : sections) {
            if (section.number == sectionNum) {
                return &section;
            }
        }

        return nullptr;
    }
};
